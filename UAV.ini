// Подключаем необходимые библиотеки
#include <ArduinoJson.h>
#include <NewPing.h>

// Определяем пины и константы
#define HC_TRIG 3              // Пин для отправки сигнала ультразвукового датчика
#define HC_ECHO 2              // Пин для приема сигнала ультразвукового датчика
#define MAX_DISTANCE 800       // Максимальное расстояние измерения в см
#define FILTER_COEFFICIENT 0.2 // Коэффициент фильтрации для сглаживания измерений
#define MEASUREMENT_INTERVAL 10 // Интервал между измерениями в мс
#define SPEED_OF_SOUND 343.0   // Скорость звука в м/с
#define CALIBRATION_SAMPLES 10 // Количество измерений для калибровки
#define THRESHOLD_DISTANCE 500 // Пороговое расстояние для бинарного режима в см
#define BINARY_OUTPUT_PIN 4    // Пин для бинарного выхода

// Создаем объект ультразвукового датчика
NewPing sonar(HC_TRIG, HC_ECHO, MAX_DISTANCE);

// Глобальные переменные
float distFilt = 0;           // Отфильтрованное расстояние
float calibrationOffset = 0;  // Калибровочное смещение
float lastDist = 0;           // Последнее измеренное расстояние
unsigned long lastTime = 0;   // Время последнего измерения

void setup() {
  // Инициализация последовательного порта
  Serial.begin(115200);
  
  // Настройка пинов
  pinMode(HC_TRIG, OUTPUT);
  pinMode(HC_ECHO, INPUT);
  pinMode(BINARY_OUTPUT_PIN, OUTPUT);
  
  // Калибровка датчика
  calibrationOffset = calibrateOffset();
  Serial.print("Калибровочное смещение: ");
  Serial.println(calibrationOffset);
}

// Здесь будет дополнено функцией гироскопа и последующего сервопривода

void loop() {
  unsigned long currentTime = millis();
  float dist = getDist();
  
  if (dist >= 0) {
    // Применяем калибровочное смещение
    dist -= calibrationOffset;
    
    // Фильтруем измерение
    distFilt += (dist - distFilt) * FILTER_COEFFICIENT;
    
    // Вычисляем скорость приближения
    float timeDiff = (currentTime - lastTime) / 1000.0;
    float approachSpeed = (lastDist - distFilt) / timeDiff;
    
    // Определяем, близко ли препятствие
    bool obstacleClose = (distFilt < THRESHOLD_DISTANCE);
    digitalWrite(BINARY_OUTPUT_PIN, obstacleClose);
    
    // Формируем JSON с данными
    StaticJsonDocument<200> doc;
    doc["distance"] = distFilt;
    doc["raw_distance"] = dist;
    doc["approach_speed"] = approachSpeed;
    doc["obstacle_close"] = obstacleClose;
    
    // Отправляем JSON через последовательный порт
    serializeJson(doc, Serial);
    Serial.println();
    
    // Сохраняем текущие значения для следующего цикла
    lastDist = distFilt;
    lastTime = currentTime;
  }
  
  // Ждем до следующего измерения
  delay(MEASUREMENT_INTERVAL);
}

// Функция для получения расстояния от датчика
float getDist() {
  float distance = sonar.ping_cm();
  if (distance == 0) {
    return -1.0;  // Возвращаем -1, если измерение не удалось
  }
  return distance;
}

// Функция для калибровки датчика
float calibrateOffset() {
  float sum = 0;
  for (int i = 0; i < CALIBRATION_SAMPLES; i++) {
    float measurement = getDist();
    if (measurement >= 0) {
      sum += measurement;
    }
    delay(50);
  }
  return sum / CALIBRATION_SAMPLES;
}